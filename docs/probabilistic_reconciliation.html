<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.0.38">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Simon Dirmeier">

<title>Probabilistic forecast reconciliation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>


<script src="probabilistic_reconciliation_files/libs/clipboard/clipboard.min.js"></script>
<script src="probabilistic_reconciliation_files/libs/quarto-html/quarto.js"></script>
<script src="probabilistic_reconciliation_files/libs/quarto-html/popper.min.js"></script>
<script src="probabilistic_reconciliation_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="probabilistic_reconciliation_files/libs/quarto-html/anchor.min.js"></script>
<link href="probabilistic_reconciliation_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="probabilistic_reconciliation_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="probabilistic_reconciliation_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="probabilistic_reconciliation_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="probabilistic_reconciliation_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc">
   
  <ul>
  <li><a href="#probabilistic-reconciliation" id="toc-probabilistic-reconciliation" class="nav-link active" data-scroll-target="#probabilistic-reconciliation">Probabilistic reconciliation</a></li>
  <li><a href="#data" id="toc-data" class="nav-link" data-scroll-target="#data">Data</a></li>
  <li><a href="#forecasts" id="toc-forecasts" class="nav-link" data-scroll-target="#forecasts">Forecasts</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#session-info" id="toc-session-info" class="nav-link" data-scroll-target="#session-info">Session info</a></li>
  <li><a href="#license" id="toc-license" class="nav-link" data-scroll-target="#license">License</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Probabilistic forecast reconciliation</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Simon Dirmeier </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November, 2022</p>
    </div>
  </div>
    
  </div>
  

</header>

<p>In this case study we implement and test methods for probabilistic forecast reconciliation based on the recent papers by <span class="citation" data-cites="panagiotelis2022probabilistic">Panagiotelis et al. (<a href="#ref-panagiotelis2022probabilistic" role="doc-biblioref">2022</a>)</span> and <span class="citation" data-cites="zambon2022probabilistic">Zambon, Azzimonti, and Corani (<a href="#ref-zambon2022probabilistic" role="doc-biblioref">2022</a>)</span>.</p>
<p>Forecast reconciliation is often found in hierarchical time series analysis scenarios, i.e., where time series can be (dis-)aggregated linearly by various attributes in a hierarchical way. For instance, consider a scenario in retail forecasting where we are interested in predicting the number of sold books per day. Forecasts are often required for all levels of a hierarchy, i.e., for the time series on the very bottom (e.g., cities), the inner nodes of a hierarchy (e.g., regions, counties) and the root node of the hierarchy (e.g., country) and it is natural to want the forecasts to add up in the same way as the data. For example, forecasts of sales per city should add up to forecasts of sales per canton, etc. In this case the hierarchy is induced by the granularity of the location as exemplified by the tree below:</p>
<div class="cell" data-tags="[&quot;hide&quot;]" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> networkx.drawing.nx_pydot <span class="im">import</span> graphviz_layout</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> nx.DiGraph()</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>G.add_edge(<span class="st">"Switzerland"</span>, <span class="st">"Greater-Zurich"</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>G.add_edge(<span class="st">"Switzerland"</span>, <span class="st">"Ticino"</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>G.add_edge(<span class="st">"Greater-Zurich"</span>, <span class="st">"Zurich"</span>)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>G.add_edge(<span class="st">"Greater-Zurich"</span>, <span class="st">"Winterthur"</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>G.add_edge(<span class="st">"Ticino"</span>, <span class="st">"Lugano"</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>G.add_edge(<span class="st">"Ticino"</span>, <span class="st">"Bellinzona"</span>)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> {</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Switzerland"</span>: (<span class="dv">4</span>, <span class="dv">1</span>), </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Greater-Zurich"</span>: (<span class="dv">6</span>, <span class="fl">0.5</span>),</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Zurich"</span>: (<span class="dv">5</span>, <span class="dv">0</span>),</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Winterthur"</span>: (<span class="dv">7</span>, <span class="dv">0</span>),</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Ticino"</span>: (<span class="dv">2</span>, <span class="fl">0.5</span>), </span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Lugano"</span>: (<span class="dv">1</span>, <span class="dv">0</span>),</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Bellinzona"</span>: (<span class="dv">3</span>, <span class="dv">0</span>),</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>options <span class="op">=</span> {</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="st">"node_color"</span>: <span class="st">"white"</span>,</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="st">"edgecolors"</span>: <span class="st">"black"</span>,</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="st">"linewidths"</span>: <span class="dv">0</span>,</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="st">"width"</span>: <span class="dv">2</span>,</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">3</span>))</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G, pos<span class="op">=</span>pos, <span class="op">**</span>options)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">"off"</span>)</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="probabilistic_reconciliation_files/figure-html/cell-2-output-1.png" width="466" height="241"></p>
</div>
</div>
<p>Propabilistic forecast reconciliation aims at generating <em>coherent</em> probabilistic forecasts over all levels of the hierarchy.</p>
<p>Before we implement the two methods introduced in <span class="citation" data-cites="panagiotelis2022probabilistic">Panagiotelis et al. (<a href="#ref-panagiotelis2022probabilistic" role="doc-biblioref">2022</a>)</span> and <span class="citation" data-cites="zambon2022probabilistic">Zambon, Azzimonti, and Corani (<a href="#ref-zambon2022probabilistic" role="doc-biblioref">2022</a>)</span>, we briefly introduce probabilistic reconciliation. We then implement and test the two methods where we use <a href="https://github.com/JaxGaussianProcesses/GPJax"><code>GPJax</code></a> to produce forecasts with Gaussian processes. I bundled the code for this case study as a Python package called <code>reconcile</code> which can be found <a href="https://github.com/dirmeier/reconcile">here</a>.</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> distrax</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> gpjax <span class="im">as</span> gpx</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> jax <span class="im">import</span> numpy <span class="im">as</span> jnp</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> jax <span class="im">import</span> random</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> optax</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pathlib</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> reconcile.forecast <span class="im">import</span> Forecaster</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> reconcile.grouping <span class="im">import</span> Grouping</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> reconcile.probabilistic_reconciliation <span class="im">import</span> ProbabilisticReconciliation</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> palettes</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> jax.config <span class="im">import</span> config</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>config.update(<span class="st">"jax_enable_x64"</span>, <span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>&lt;frozen importlib._bootstrap&gt;:228: RuntimeWarning: scipy._lib.messagestream.MessageStream size changed, may indicate binary incompatibility. Expected 56 from C header, got 64 from PyObject</code></pre>
</div>
</div>
<section id="probabilistic-reconciliation" class="level1">
<h1>Probabilistic reconciliation</h1>
<p>Denote with <span class="math inline">\(\mathbf{b}^t \in \mathbb{R}^P\)</span> a vector of observations of “bottom-level” time series at time <span class="math inline">\(t\)</span> and with <span class="math inline">\(y^t_{n}\)</span> an observation of node <span class="math inline">\(n\)</span> at time <span class="math inline">\(t\)</span>. For instance, in the example above <span class="math inline">\(\mathbf{b}^t = \{y^t_{\text{Lugano}}, y^t_{\text{Bellinzona}}, y^t_{\text{Zurich}}, y^t_{\text{Winterthur}} \}\)</span>. We can aggregate the bottom level observations such that the parents of nodes are sums of their children, via an summing matrix <span class="math inline">\(\mathbf{S} \in \{0, 1\}^{Q \times P}\)</span></p>
<p><span class="math display">\[
\mathbf{y}^t = \mathbf{Sb}
\]</span></p>
<p>where <span class="math inline">\(\mathbf{S}\)</span> defines the hierarchical structure of the time series. Again, as an example, for the hierarchy above</p>
<p><span class="math display">\[
\mathbf{S} =  
\begin{pmatrix}
\mathbf{A}\\
\mathbf{I}\\
\end{pmatrix} =
\begin{pmatrix}
1 &amp; 1 &amp; 1 &amp; 1\\
1 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1 &amp; 1\\
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{pmatrix}
\]</span></p>
<p>where <span class="math inline">\(\mathbf{A}\)</span> is called aggregation matrix, <span class="math inline">\(\mathbf{I}\)</span> is a diagonal matrix, and the vector <span class="math inline">\(\mathbf{y}^t =\{y^t_{\text{Switzerland}}, y^t_{\text{Ticino}}, y^t_{\text{Greater-Zurich}}, y^t_{\text{Lugano}},y^t_{\text{Bellinzona}}, y^t_{\text{Zurich}}, y^t_{\text{Winterthur}}\}\)</span> contains all the time series over the hierarchy. When we generate forecasts <span class="math inline">\(\hat{\mathbf{y}}\)</span> for all of these timeseries, they might not cohere to the linear constraints induced by the hierarchy.</p>
<p>In a probabilistic (e.g., Bayesian) framework forecasts are available in the form of probability distributions. Following <span class="citation" data-cites="zambon2022probabilistic">Zambon, Azzimonti, and Corani (<a href="#ref-zambon2022probabilistic" role="doc-biblioref">2022</a>)</span>, we denote <span class="math inline">\(\hat{\nu} \in \mathbb{P}(\mathbb{R}^Q)\)</span> the forecast distribution of <span class="math inline">\(\hat{\mathbf{y}}\)</span> and call it coherent (<span class="math inline">\(\tilde{\nu}\)</span>) if <span class="math inline">\(\text{supp}(\hat{\nu})\)</span> is in a linear subspace <span class="math inline">\(\mathcal{S}\)</span> of dimension <span class="math inline">\(P\)</span> of <span class="math inline">\(\mathbb{R}^Q\)</span>.</p>
<p>To find a coherent forecast distribution <span class="math inline">\(\tilde{\nu}\)</span>, <span class="citation" data-cites="panagiotelis2022probabilistic">Panagiotelis et al. (<a href="#ref-panagiotelis2022probabilistic" role="doc-biblioref">2022</a>)</span> propose to fit a map <span class="math inline">\(\psi: \mathbb{R}^Q \rightarrow \mathcal{S}\)</span>, such that <span class="math inline">\(\tilde{\nu} = \psi_{\sharp}\hat{\nu}\)</span>. <span class="citation" data-cites="panagiotelis2022probabilistic">Panagiotelis et al. (<a href="#ref-panagiotelis2022probabilistic" role="doc-biblioref">2022</a>)</span> use a simple linear transformation <span class="math inline">\(\psi(\mathbf{y}) = \mathbf{S}(\mathbf{d} + \mathbf{W}\mathbf{y})\)</span> and fit it using an approximate energy score as objective.</p>
<p><span class="citation" data-cites="zambon2022probabilistic">Zambon, Azzimonti, and Corani (<a href="#ref-zambon2022probabilistic" role="doc-biblioref">2022</a>)</span> propose sampling from the reconciled base forecast density <span class="math inline">\(\tilde{\pi}(\mathbf{b})\)</span> of <span class="math inline">\(\mathbf{b}\)</span> via <span class="math inline">\(\tilde{\pi}(\mathbf{b}) \propto \pi_U(\mathbf{A}\mathbf{b}) \pi_B(\mathbf{b})\)</span> where <span class="math inline">\(\mathbf{A}\)</span> is the aggregation matrix, and <span class="math inline">\(\pi_U\)</span> and <span class="math inline">\(\pi_B\)</span> are the predictive densities of the upper level time series, i.e., the ones corresponding to the inner nodes and root, and bottom level time series.</p>
<p>For further details, please refer to the original publications.</p>
</section>
<section id="data" class="level1">
<h1>Data</h1>
<p>We will test the two methods on a finance data set, specifically stock index data of some constituents of the SP500 which we take from <a href="https://datahub.io/core/s-and-p-500-companies-financials#resource-constituents">datahub</a> and <a href="https://www.kaggle.com/datasets/paultimothymooney/stock-market-data?resource=download">Kaggle</a>.</p>
<p>Of the SP500, we somewhat arbitrarily picked some consituents from the health care and information technology industries and selected all entries from 2022 on. In that case the hierarchy consists of two levels, where “Health Care” and “Information Technology” are the parents of the different companies (which are leaves).</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> preprocess():</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    constituents_sp500 <span class="op">=</span> pd.read_csv(<span class="st">"./constituents.csv"</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    constituents_sp500 <span class="op">=</span> constituents_sp500[</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        (constituents_sp500.Sector <span class="op">==</span> <span class="st">"Health Care"</span>) <span class="op">|</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        (constituents_sp500.Sector <span class="op">==</span> <span class="st">"Information Technology"</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    dfs <span class="op">=</span> []</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> constituent <span class="kw">in</span> constituents_sp500.iterrows():</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        path <span class="op">=</span> <span class="ss">f"./stocks/</span><span class="sc">{</span>constituent[<span class="dv">1</span>]<span class="sc">.</span>Symbol<span class="sc">}</span><span class="ss">.csv"</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pathlib.Path(path).exists():</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>            df <span class="op">=</span> pd.read_csv(path)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>            df[<span class="st">"Sector"</span>] <span class="op">=</span> constituent[<span class="dv">1</span>].Sector</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>            df[<span class="st">"Name"</span>] <span class="op">=</span> constituent[<span class="dv">1</span>].Name</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>            dfs.append(df)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.concat(dfs)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    df_constituents <span class="op">=</span> [</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Illumina Inc"</span>, <span class="st">"Johnson &amp; Johnson"</span>, <span class="st">"Pfizer Inc."</span>, <span class="st">"Thermo Fisher Scientific"</span>, <span class="st">"Merck &amp; Co."</span>,</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Activision Blizzard"</span>, <span class="st">"Boston Scientific"</span>, <span class="st">"Netflix Inc."</span>, <span class="st">"Microsoft Corp."</span>, <span class="st">"Seagate Technology"</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df[df.Name.isin(df_constituents)]</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    df.Date <span class="op">=</span> pd.to_datetime(df.Date, infer_datetime_format<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df[df.Date <span class="op">&gt;</span> np.datetime64(<span class="st">"2021-12-31"</span>)]</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> preprocess()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s have a look at the different stock time series.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"Standardized"</span>] <span class="op">=</span> df.groupby(</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    [<span class="st">"Sector"</span>, <span class="st">"Name"</span>]</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>)[<span class="st">"Close"</span>].transform(<span class="kw">lambda</span> x: (x <span class="op">-</span> x.mean()) <span class="op">/</span> x.std())</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> sns.FacetGrid(</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    df,</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    row<span class="op">=</span><span class="st">"Sector"</span>,</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    hue<span class="op">=</span><span class="st">"Name"</span>,</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    palette<span class="op">=</span>sns.color_palette(<span class="st">"crest"</span>),</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    sharex<span class="op">=</span><span class="va">False</span>, </span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    sharey<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    height<span class="op">=</span><span class="fl">2.5</span>, </span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    aspect<span class="op">=</span><span class="dv">3</span>,</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> g.map_dataframe(</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    sns.lineplot, x<span class="op">=</span><span class="st">"Date"</span>, y<span class="op">=</span><span class="st">"Standardized"</span>, style<span class="op">=</span><span class="st">"Name"</span>,</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> g.set_axis_labels(<span class="st">""</span>, <span class="st">"Standardized index"</span>)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.drop(columns<span class="op">=</span><span class="st">"Standardized"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="probabilistic_reconciliation_files/figure-html/cell-5-output-1.png" width="710" height="452"></p>
</div>
</div>
<p>Before we try start forecasting these, we postprocess the data, e.g., by transforming the dates into numeric values and then extract them from the data frame as arrays.</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> postprocess(df):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">"Series"</span>] <span class="op">=</span> df[<span class="st">"Sector"</span>] <span class="op">+</span> <span class="st">":"</span> <span class="op">+</span> df[<span class="st">"Name"</span>]</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df[[<span class="st">"Date"</span>, <span class="st">"Series"</span>, <span class="st">"Close"</span>]]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.rename(columns<span class="op">=</span>{<span class="st">"Close"</span>: <span class="st">"Value"</span>})</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.pivot(index<span class="op">=</span><span class="st">"Date"</span>, columns<span class="op">=</span><span class="st">'Series'</span>, values<span class="op">=</span><span class="st">'Value'</span>).reset_index()</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.dropna()</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    df.insert(<span class="dv">0</span>, <span class="st">"x"</span>, (df.Date <span class="op">-</span> np.<span class="bu">min</span>(df.Date)) <span class="op">/</span> (np.<span class="bu">max</span>(df.Date) <span class="op">-</span> np.<span class="bu">min</span>(df.Date)))</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_bottom_level_timeseries(df):</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> df.x.values.reshape(<span class="dv">1</span>,  <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> df.drop(columns<span class="op">=</span>[<span class="st">"Date"</span>, <span class="st">"x"</span>]).values.T</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> b.reshape(<span class="dv">1</span>, <span class="op">*</span>b.shape)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> b, x</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> postprocess(df)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>b, x <span class="op">=</span> get_bottom_level_timeseries(D)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Using <code>reconcile</code> we can define a hierarchy (or more generally a grouping) using the <code>Grouping</code> class. To do so, we first create a “:”-separated string for every bottom level time series that specifies the path of the time series to the root of the hierarchy.</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>hierarchy <span class="op">=</span> <span class="bu">list</span>(D.drop(columns<span class="op">=</span>[<span class="st">"Date"</span>, <span class="st">"x"</span>]).columns)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>hierarchy</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>['Health Care:Boston Scientific',
 'Health Care:Illumina Inc',
 'Health Care:Johnson &amp; Johnson',
 'Health Care:Merck &amp; Co.',
 'Health Care:Pfizer Inc.',
 'Health Care:Thermo Fisher Scientific',
 'Information Technology:Activision Blizzard',
 'Information Technology:Microsoft Corp.',
 'Information Technology:Netflix Inc.',
 'Information Technology:Seagate Technology']</code></pre>
</div>
</div>
<p>Since in our example, the hierarchy is very flat (only one inner level), the strings are only separated by one colon. For instance “Boston Scientific” is in the health care sector, hence we create an entry “Health Care:Boston Scientific”. We then create a grouping using the list of strings.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>groups <span class="op">=</span> pd.DataFrame({<span class="st">"hierarchy"</span>: hierarchy})</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>grouping <span class="op">=</span> Grouping(groups)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="forecasts" class="level1">
<h1>Forecasts</h1>
<p>Before we can probabilistically reconcile forecasts, we first need to generate probabilistic forecasts (yupp), or rather predictive distributions. We use <code>GPJax</code>’s Gaussian process implementations for this. Specifically, we fit a Gaussian process to every time series separately and then, in a post-processing step, reconcile those forecasts.</p>
<p>GPs are arguably not the best model here, but for the sake of demonstrating the two reconciliation methods it is fine, since we don’t aim to make perfectly accurate predictions here.</p>
<p>We first get all the time series, i.e, bottom and upper level time series, from the <code>Grouping</code> object.</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>all_timeseries <span class="op">=</span> grouping.all_timeseries(b)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>all_features <span class="op">=</span> jnp.tile(x, [<span class="dv">1</span>, all_timeseries.shape[<span class="dv">1</span>], <span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We then define a forecasting class. The class needs to inherit from <code>Forecaster</code> which is implemented in the Python package we developed for this case study. The class needs to provide a <code>fit</code> method that fits all of the time series, a <code>posterior_predictive</code> method which returns a posterior predictive distribution of all time series as <code>distrax</code> object, and a method <code>predictive_posterior_probability</code> that computes the probabilty of observing some event under the posterior predictive.</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> GPForecaster(Forecaster):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Example implementation of a forecaster"""</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._models <span class="op">=</span> []</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._xs <span class="op">=</span> <span class="va">None</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._ys <span class="op">=</span> <span class="va">None</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">@property</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> data(<span class="va">self</span>):</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Returns the data"""</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>._ys, <span class="va">self</span>._xs</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fit(<span class="va">self</span>, rng_key, ys, xs):</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Fit a model to each of the time series"""</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._xs <span class="op">=</span> xs</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._ys <span class="op">=</span> ys</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> xs.shape[<span class="dv">1</span>]</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._models <span class="op">=</span> [<span class="va">None</span>] <span class="op">*</span> p</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> np.arange(p):</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>            x, y <span class="op">=</span> xs[:, [i], :], ys[:, [i], :]</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>            <span class="co"># fit a model for each time series</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>            learned_params, D <span class="op">=</span> <span class="va">self</span>._fit_one(rng_key, x, y)</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>            <span class="co"># save the learned parameters and the original data</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._models[i] <span class="op">=</span> learned_params, D</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _fit_one(<span class="va">self</span>, rng_key, x, y):</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>        <span class="co"># here we use GPs to model the time series</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>        D <span class="op">=</span> gpx.Dataset(X<span class="op">=</span>x.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>), y<span class="op">=</span>y.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>        posterior, likelihood <span class="op">=</span> <span class="va">self</span>._model(rng_key, D.n)</span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>        parameter_state <span class="op">=</span> gpx.initialise(posterior, key<span class="op">=</span>rng_key)</span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>        mll <span class="op">=</span> jax.jit(posterior.marginal_log_likelihood(D, negative<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>        optimiser <span class="op">=</span> optax.adam(learning_rate<span class="op">=</span><span class="fl">5e-2</span>)</span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>        inference_state <span class="op">=</span> gpx.fit(mll, parameter_state, optimiser, n_iters<span class="op">=</span><span class="dv">2000</span>, verbose<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>        learned_params, _ <span class="op">=</span> inference_state.unpack()</span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> learned_params, D</span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>    <span class="at">@staticmethod</span></span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _model(rng_key, n):</span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a>        D <span class="op">=</span> gpx.Dataset(X<span class="op">=</span>x[<span class="dv">0</span>, <span class="dv">0</span>].reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>), y<span class="op">=</span>b[<span class="dv">0</span>, <span class="dv">0</span>].reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a>        kernel <span class="op">=</span> gpx.RBF() <span class="op">+</span> gpx.Matern32()</span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a>        prior <span class="op">=</span> gpx.Prior(mean_function<span class="op">=</span>gpx.Constant(), kernel<span class="op">=</span>kernel)</span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a>        likelihood <span class="op">=</span> gpx.Gaussian(num_datapoints<span class="op">=</span>D.n)</span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a>        posterior <span class="op">=</span> prior <span class="op">*</span> likelihood</span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true" tabindex="-1"></a>       </span>
<span id="cb11-50"><a href="#cb11-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> posterior, likelihood</span>
<span id="cb11-51"><a href="#cb11-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-52"><a href="#cb11-52" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> posterior_predictive(<span class="va">self</span>, rng_key, xs_test):</span>
<span id="cb11-53"><a href="#cb11-53" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Compute the joint</span></span>
<span id="cb11-54"><a href="#cb11-54" aria-hidden="true" tabindex="-1"></a><span class="co">        posterior predictive distribution of all timeseries at xs_test"""</span></span>
<span id="cb11-55"><a href="#cb11-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-56"><a href="#cb11-56" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> xs_test.shape[<span class="dv">1</span>]</span>
<span id="cb11-57"><a href="#cb11-57" aria-hidden="true" tabindex="-1"></a>        means <span class="op">=</span> [<span class="va">None</span>] <span class="op">*</span> q</span>
<span id="cb11-58"><a href="#cb11-58" aria-hidden="true" tabindex="-1"></a>        covs <span class="op">=</span> [<span class="va">None</span>] <span class="op">*</span> q</span>
<span id="cb11-59"><a href="#cb11-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> np.arange(q):</span>
<span id="cb11-60"><a href="#cb11-60" aria-hidden="true" tabindex="-1"></a>            x_test <span class="op">=</span> xs_test[:, [i], :].reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb11-61"><a href="#cb11-61" aria-hidden="true" tabindex="-1"></a>            learned_params, D <span class="op">=</span> <span class="va">self</span>._models[i]</span>
<span id="cb11-62"><a href="#cb11-62" aria-hidden="true" tabindex="-1"></a>            posterior, likelihood <span class="op">=</span> <span class="va">self</span>._model(rng_key, D.n)</span>
<span id="cb11-63"><a href="#cb11-63" aria-hidden="true" tabindex="-1"></a>            latent_distribution <span class="op">=</span> posterior(learned_params, D)(x_test)</span>
<span id="cb11-64"><a href="#cb11-64" aria-hidden="true" tabindex="-1"></a>            predictive_dist <span class="op">=</span> likelihood(learned_params, latent_distribution)</span>
<span id="cb11-65"><a href="#cb11-65" aria-hidden="true" tabindex="-1"></a>            means[i] <span class="op">=</span> predictive_dist.mean()</span>
<span id="cb11-66"><a href="#cb11-66" aria-hidden="true" tabindex="-1"></a>            cov <span class="op">=</span> jnp.linalg.cholesky(predictive_dist.covariance_matrix)</span>
<span id="cb11-67"><a href="#cb11-67" aria-hidden="true" tabindex="-1"></a>            covs[i] <span class="op">=</span> cov.reshape((<span class="dv">1</span>, <span class="op">*</span>cov.shape))</span>
<span id="cb11-68"><a href="#cb11-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-69"><a href="#cb11-69" aria-hidden="true" tabindex="-1"></a>        <span class="co"># here we stack the means and covariance functions of all</span></span>
<span id="cb11-70"><a href="#cb11-70" aria-hidden="true" tabindex="-1"></a>        <span class="co"># GP models we used</span></span>
<span id="cb11-71"><a href="#cb11-71" aria-hidden="true" tabindex="-1"></a>        means <span class="op">=</span> jnp.vstack(means)</span>
<span id="cb11-72"><a href="#cb11-72" aria-hidden="true" tabindex="-1"></a>        covs <span class="op">=</span> jnp.vstack(covs)</span>
<span id="cb11-73"><a href="#cb11-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-74"><a href="#cb11-74" aria-hidden="true" tabindex="-1"></a>        <span class="co"># here we use a single distrax distribution to model the predictive</span></span>
<span id="cb11-75"><a href="#cb11-75" aria-hidden="true" tabindex="-1"></a>        <span class="co"># posterior of _all_ models</span></span>
<span id="cb11-76"><a href="#cb11-76" aria-hidden="true" tabindex="-1"></a>        posterior_predictive <span class="op">=</span> distrax.MultivariateNormalTri(means, covs)</span>
<span id="cb11-77"><a href="#cb11-77" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> posterior_predictive</span>
<span id="cb11-78"><a href="#cb11-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-79"><a href="#cb11-79" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> predictive_posterior_probability(</span>
<span id="cb11-80"><a href="#cb11-80" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>, rng_key, ys_test, xs_test</span>
<span id="cb11-81"><a href="#cb11-81" aria-hidden="true" tabindex="-1"></a>    ):</span>
<span id="cb11-82"><a href="#cb11-82" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Compute the log predictive posterior probability of an observation"""</span></span>
<span id="cb11-83"><a href="#cb11-83" aria-hidden="true" tabindex="-1"></a>        preds <span class="op">=</span> <span class="va">self</span>.posterior_predictive(rng_key, xs_test)</span>
<span id="cb11-84"><a href="#cb11-84" aria-hidden="true" tabindex="-1"></a>        lp <span class="op">=</span> preds.log_prob(ys_test)</span>
<span id="cb11-85"><a href="#cb11-85" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lp</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The time series have a total length of 204 of which we take the first 200 for training.</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>all_timeseries.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>(1, 13, 204)</code></pre>
</div>
</div>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>idx_train <span class="op">=</span> <span class="dv">200</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We then fit the <code>GPForecaster</code> to the time series.</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>forecaster <span class="op">=</span> GPForecaster()</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>forecaster.fit(</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    random.PRNGKey(<span class="dv">1</span>), all_timeseries[:, :, :idx_train], all_features[:, :, :idx_train]</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/Users/simon/miniconda3/envs/etudes/lib/python3.9/site-packages/gpjax/parameters.py:180: UserWarning: Parameter constant has no transform. Defaulting to identity transfom.
  warnings.warn(</code></pre>
</div>
</div>
<p>As baseline to the two reconciliation methods, we also sample from the posterior predictive of the base forecasts.</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>y_predictive <span class="op">=</span> forecaster.posterior_predictive(</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    random.PRNGKey(<span class="dv">1</span>), all_features</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>y_predictive_samples <span class="op">=</span> y_predictive.sample(</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    seed<span class="op">=</span>random.PRNGKey(<span class="dv">2</span>), sample_shape<span class="op">=</span>(<span class="dv">1000</span>,)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>b_predictive_mean <span class="op">=</span> jnp.mean(y_predictive_samples, axis<span class="op">=</span><span class="dv">0</span>, keepdims<span class="op">=</span><span class="va">True</span>)[:, <span class="dv">3</span>:, :]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>D_pred <span class="op">=</span> pd.DataFrame(b_predictive_mean[<span class="dv">0</span>].T, columns<span class="op">=</span>hierarchy)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>D_pred.insert(<span class="dv">0</span>, <span class="st">"Data type"</span>, <span class="st">"Predicted"</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>D_pred.insert(<span class="dv">1</span>, <span class="st">"Date"</span>, D.Date)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next we use a method similar to <span class="citation" data-cites="panagiotelis2022probabilistic">Panagiotelis et al. (<a href="#ref-panagiotelis2022probabilistic" role="doc-biblioref">2022</a>)</span> to reconcile the base forecasts.</p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>recon <span class="op">=</span> ProbabilisticReconciliation(grouping, forecaster)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>b_pred_fit_recon <span class="op">=</span> recon.fit_reconciled_posterior_predictive(</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>   random.PRNGKey(<span class="dv">1</span>), all_features, n_samples<span class="op">=</span><span class="dv">1000</span>, n_iter<span class="op">=</span><span class="dv">1000</span>,</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>b_pred_fit_recon_mean <span class="op">=</span> jnp.mean(b_pred_fit_recon, axis<span class="op">=</span><span class="dv">0</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>D_fit_recon <span class="op">=</span> pd.DataFrame(b_pred_fit_recon_mean[<span class="dv">0</span>].T, columns<span class="op">=</span>hierarchy)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>D_fit_recon.insert(<span class="dv">0</span>, <span class="st">"Data type"</span>, <span class="st">"Reconciled via optimization"</span>)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>D_fit_recon.insert(<span class="dv">1</span>, <span class="st">"Date"</span>, D.Date)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We use the MCMC-based method in <span class="citation" data-cites="zambon2022probabilistic">Zambon, Azzimonti, and Corani (<a href="#ref-zambon2022probabilistic" role="doc-biblioref">2022</a>)</span> for sampling-based reconciliation.</p>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>b_pred_sample_recon <span class="op">=</span> recon.sample_reconciled_posterior_predictive(</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>   random.PRNGKey(<span class="dv">1</span>), all_features</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>b_pred_sample_recon_mean <span class="op">=</span> jnp.mean(</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    jnp.mean(b_pred_sample_recon, axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">False</span>), axis<span class="op">=</span><span class="dv">0</span>, keepdims<span class="op">=</span><span class="va">True</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>D_sample_recon <span class="op">=</span> pd.DataFrame(b_pred_sample_recon_mean[<span class="dv">0</span>].T, columns<span class="op">=</span>hierarchy)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>D_sample_recon.insert(<span class="dv">0</span>, <span class="st">"Data type"</span>, <span class="st">"Reconciled via sampling"</span>)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>D_sample_recon.insert(<span class="dv">1</span>, <span class="st">"Date"</span>, D.Date)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s visualize the results. We first aggregate all forecasts in a data frame and then plot the original data, the base forecasts and the two recconciled forecasts.</p>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>D_all <span class="op">=</span> D.drop(columns<span class="op">=</span><span class="st">"x"</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>D_all.insert(<span class="dv">0</span>, <span class="st">"Data type"</span>, <span class="st">"Real"</span>)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>D_all <span class="op">=</span> pd.concat([D_all, D_pred, D_sample_recon, D_fit_recon], axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>D_all <span class="op">=</span> D_all.melt(id_vars<span class="op">=</span>[<span class="st">"Date"</span>, <span class="st">"Data type"</span>])</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>D_all[[<span class="st">'Sector'</span>,<span class="st">'Name'</span>]] <span class="op">=</span> D_all.variable.<span class="bu">str</span>.split(<span class="st">":"</span>,expand<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> sns.FacetGrid(</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    D_all,</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    col<span class="op">=</span><span class="st">"Name"</span>,</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    col_wrap<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    sharex<span class="op">=</span><span class="va">False</span>, </span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    sharey<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    height<span class="op">=</span><span class="fl">1.75</span>,</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    aspect<span class="op">=</span><span class="dv">2</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> g.map_dataframe(</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    sns.lineplot, x<span class="op">=</span><span class="st">"Date"</span>, y<span class="op">=</span><span class="st">"value"</span>, style<span class="op">=</span><span class="st">"Data type"</span>, color<span class="op">=</span><span class="st">"black"</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> g.tight_layout()</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> g.set_axis_labels(<span class="st">""</span>, <span class="st">"Index"</span>)</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> g.<span class="bu">set</span>(xticklabels<span class="op">=</span>[])</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> g.add_legend()</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="probabilistic_reconciliation_files/figure-html/cell-21-output-1.png" width="879" height="794"></p>
</div>
</div>
<p>The results look decent for some of the time series and even worse than the base forecasts for others. Given that the time series don’t present clear trends or saisonalities, the task was arguably a very difficult one though.</p>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>This case study implemented and tested two methods based on recent papers on probabilstic forecast reconciliation. We evaluated the methods (superficially) on stock-index time series data of the SP500 with mixed results. Stock-index data is notoriously hard to forecast due to their (apparent) stationarity, and the evaluation was consequently not very meaningful, but rather intended to understand probabilistic reconciliation methods better.</p>
<p>The methods demonstrated above are implemented in a Python package called <code>reconcile</code> which can be found on <a href="https://pypi.org/project/probabilistic-reconciliation/">PyPI</a> and <a href="https://github.com/dirmeier/reconcile">GitHub</a>.</p>
</section>
<section id="session-info" class="level1">
<h1>Session info</h1>
<div class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> session_info</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>session_info.show(html<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>-----
distrax             0.1.2
gpjax               0.5.1
jax                 0.3.25
jaxlib              0.3.25
matplotlib          3.6.2
networkx            2.8.6
numpy               1.23.4
optax               0.1.3
palettes            NA
pandas              1.5.1
reconcile           NA
seaborn             0.11.2
session_info        1.0.0
-----
IPython             8.4.0
jupyter_client      7.3.4
jupyter_core        4.10.0
jupyterlab          3.3.4
notebook            6.4.12
-----
Python 3.9.10 | packaged by conda-forge | (main, Feb  1 2022, 21:27:43) [Clang 11.1.0 ]
macOS-12.6-arm64-i386-64bit
-----
Session information updated at 2022-11-20 12:33</code></pre>
</div>
</div>
</section>
<section id="license" class="level1">
<h1>License</h1>
<p><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img align="left" alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png"></a> <br><br></p>
<p>The case study is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</p>
</section>
<section id="references" class="level1">
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-panagiotelis2022probabilistic" class="csl-entry" role="doc-biblioentry">
Panagiotelis, Anastasios, Puwasala Gamakumara, George Athanasopoulos, and Rob J Hyndman. 2022. <span>“Probabilistic Forecast Reconciliation: Properties, Evaluation and Score Optimisation.”</span> <em>European Journal of Operational Research</em>.
</div>
<div id="ref-zambon2022probabilistic" class="csl-entry" role="doc-biblioentry">
Zambon, Lorenzo, Dario Azzimonti, and Giorgio Corani. 2022. <span>“Probabilistic Reconciliation of Forecasts via Importance Sampling.”</span> <em>arXiv Preprint arXiv:2210.02286</em>.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      let href = ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>